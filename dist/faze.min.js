/*! hash:4c12c5808dc23071cf08, chunkhash:97cb2a4dd721317d2776, name:main, filebase:faze.min.js, query:, file:faze.min.js */
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/faze.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/faze.js":
/*!*********************!*\
  !*** ./src/faze.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("(function(){\r\n\r\n    var domReadyStack = [];\r\n\r\n    var isSimple = /^.[^:#[.,]*$/;\r\n    // var singleTag = /^<(\\w+)\\s*\\/?>(?:<\\/\\1>)?$/;\r\n    // var quickExpr = /^[^<]*(<[\\w\\W]+>)[^>]*$|^#([\\w-]+)$/;\r\n    // var readyBound = false;\r\n\r\n\r\n    function handleDOmReady(fn) {\r\n      return document.readyState === 'complete' ? fn.call( document ) : domReadyStack.push( fn );\r\n    }\r\n\r\n    document.addEventListener( 'DOMContentLoaded', function onDOMReady() {\r\n      document.removeEventListener( 'DOMContentLoaded', onDOMReady );\r\n      while( domReadyStack.length ) {\r\n        domReadyStack.shift().call( document );\r\n      }\r\n    });\r\n\r\n    var defaults = {\r\n      version: '1.0.1'\r\n    };\r\n\r\n    /**\r\n     * [Faze instance constructor]\r\n     * @param {Faze} selector [description]\r\n     */\r\n    var Faze = function( selector ) {\r\n\r\n      if( !(this instanceof Faze) ) {\r\n        return new Faze( selector );\r\n      }\r\n\r\n      if( !selector ){\r\n        return;\r\n      }\r\n\r\n      var extended = {};\r\n\r\n      for( var prop in defaults ) {\r\n        if(Object.prototype.hasOwnProperty.call( defaults, prop ) ) {\r\n          extended[prop] = defaults[prop];\r\n          this[prop] = defaults[prop];\r\n        }\r\n      }\r\n\r\n      this.length = 0;\r\n      this.nodes  = [];\r\n      this.events = [];\r\n      this.cache  = [];\r\n\r\n      if( selector instanceof HTMLElement || selector instanceof NodeList ) {\r\n        this.nodes = selector.length > 1 ? [].slice.call( selector ) : [ selector ];\r\n      }\r\n      else if( typeof selector === \"object\" && selector.toString() === \"[object HTMLDocument]\" ) {\r\n        this.nodes = [ selector ];\r\n        this.length = 1;\r\n      }\r\n      else if( typeof selector === 'string' ) {\r\n        if( selector[0] === '<' && selector[selector.length - 1] === '>' ) {\r\n          this.nodes = [ createNodes( selector ) ];\r\n        }\r\n        else {\r\n          if( selector.match( isSimple ) ){ \r\n            try{\r\n              this.nodes = [].slice.call( document.querySelectorAll( selector ) );\r\n            }\r\n            catch( e ){\r\n              throw new Error( e );\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      if( this.nodes.length ) {\r\n        this.length = this.nodes.length;\r\n        for( var i = 0; i < this.nodes.length; i++ ) {\r\n          this[i] = this.nodes[i];\r\n        }\r\n      }\r\n    };\r\n\r\n    Faze.fn = Faze.prototype;\r\n    window.Faze = window.fz = Faze;\r\n\r\n    // private functions ====================================\r\n\r\n    /**\r\n     * [createNodes - create custom html nodes]\r\n     * @param  {string} html [html string]\r\n     * @return {node}      [returns html node]\r\n     */\r\n    function createNodes( html ) {\r\n      var div = document.createElement( 'div' );\r\n      div.innerHTML = html;\r\n      return div.firstChild;\r\n    }\r\n\r\n    function class2type() {\r\n      return {};\r\n    }\r\n\r\n    /**\r\n     * [ test if node is window ]\r\n     * @param  {[node]}\r\n     * @return {Boolean}\r\n     */\r\n    function isWindow( obj ) {\r\n      return obj != null && obj === obj.window;\r\n    }\r\n\r\n    /**\r\n     * [check if object is array like]\r\n     * @param  {[type]}\r\n     * @return {Boolean}\r\n     */\r\n    function isLikeArray( obj ) {\r\n      var length = !!obj && obj.length;\r\n      var type = toType( obj );\r\n      if( typeof obj === \"function\" || isWindow( obj ) ) {\r\n        return false;\r\n      }\r\n\r\n      return type === \"array\" || length === 0 || typeof length === \"number\" && length > 0 && ( length -1 ) in obj;\r\n    }\r\n\r\n    function toString() {\r\n      return class2type.toString;\r\n    }\r\n\r\n    /**\r\n     * [check if node is htmlelement]\r\n     * @param  {[node]}\r\n     * @return {Boolean}\r\n     */\r\n    function isHTMLElement( option ) {\r\n      return option instanceof HTMLElement;\r\n    }\r\n\r\n    /**\r\n     * [ check if options is NodeList ]\r\n     * @param  {[HTMLCollection|NodeList]}\r\n     * @return {Boolean}\r\n     */\r\n    function isNodeList( options ) {\r\n      return options instanceof NodeList();\r\n    }\r\n\r\n    /**\r\n     * @param  {[Object]}\r\n     * @return {[type]}\r\n     */\r\n    function toType( obj ) {\r\n      if( obj == null ) {\r\n        return obj + \"\";\r\n      }\r\n\r\n      return typeof obj === \"object\" ? \r\n        class2type[ toString.call( obj ) ] || \"object\" :\r\n        typeof obj;\r\n    }\r\n\r\n    /**\r\n     * Loop through each element\r\n     * @param  {Function} callback [callback function]\r\n     * @return {Faze}            [returns faze instance]\r\n     */\r\n    Faze.fn.each = function( callback ) {\r\n      for( var i = 0; i < this.length; i++ ) {\r\n        callback.call( this, this[i], i );\r\n      }\r\n      return this;\r\n    } \r\n\r\n    /**\r\n     * [domReady function]\r\n     */\r\n    Faze.fn.domReady = handleDOmReady;\r\n\r\n    /**\r\n     * [isHTMLElement function]\r\n     */\r\n    Faze.fn.isHTMLElement = isHTMLElement;\r\n\r\n    /**\r\n     * [isNodeList function]\r\n     * @type {Boolean}\r\n     */\r\n    Faze.fn.isNodeList = isNodeList;\r\n\r\n    // class helper ======================================\r\n    /**\r\n     * [Add a class to DOM Elements]\r\n     * @param {[string]} classname [string of the classname]\r\n     */\r\n    Faze.fn.addClass = function( classname ) {\r\n      this.each( function( item ) {\r\n        item.classList.add( classname );\r\n      }); \r\n      return this;\r\n    } \r\n\r\n    /**\r\n     * [Remove class from DOM Elements]\r\n     * @param  {[type]} classname [description]\r\n     */\r\n    Faze.fn.removeClass = function( classname ) {\r\n      this.each( function( item ) {\r\n        item.classList.remove( classname );\r\n      });\r\n    }\r\n\r\n    /**\r\n     * [add or remove classname from DOM Elements]\r\n     * @param  {[string]} classname [description]\r\n     */\r\n    Faze.fn.toggleClass = function( classname ) {\r\n      this.each( function( item ) {\r\n        if( item.classList.contains( classname ) ) {\r\n          this.removeClass( classname );\r\n        }\r\n        else {\r\n          this.addClass( classname );\r\n        }\r\n      });\r\n    }\r\n\r\n    /**\r\n     * [Check if DOM Elements has classname]\r\n     * @param  {[string]}  classname [classname as string]\r\n     * @return {Boolean}           \r\n     */\r\n    Faze.fn.hasClass = function( classname ) {\r\n      var hasClass = false;\r\n      var useMatch = classname.split( /[.#:~*]/ ).length > 1 ? true : false;\r\n      this.each( function( item ) {\r\n        if( useMatch ) {\r\n          hasClass = item.matches( classname );\r\n        }\r\n        else {\r\n          hasClass = item.classList.contains( classname );\r\n        }\r\n      });\r\n      return hasClass;\r\n    }\r\n\r\n    // styling ============================================\r\n    /**\r\n     * [Add CSS to a DOM elements]\r\n     * @param  {[string|object]} opt1 [String for css attribute name | object with css methods]\r\n     * @param  {[optional|string]} opt2 [string for setting CSS value]\r\n     */\r\n    Faze.fn.css = function( opt1, opt2 ) {\r\n      if( typeof opt1 === 'string' && typeof opt2 === 'string' ) {\r\n        this.each( function( item ) {\r\n          if( null !== item.style[opt1] ) {\r\n            item.style[opt1] = opt2;\r\n          }\r\n        });\r\n      }\r\n      else if( typeof opt1 === \"object\" ) {\r\n        this.each( function( item ) {\r\n          Faze( opt1 ).each( function( option, index ) {\r\n            item.style[index] = option[index];\r\n          })\r\n        });\r\n      }\r\n    }\r\n\r\n    /**\r\n     * [Change color by ammount]\r\n     * @param  {[string]} color   [hexidecimal or rgb color value]\r\n     * @param  {[int]} ammount [percentage to change color by]\r\n     * @return {[string]}         [returns hexidecimnal or rgb]\r\n     */\r\n    Faze.fn.changeColour = function( color, ammount ) {\r\n      var useHash = false;\r\n\r\n      if( color[0] === '#' ) {\r\n        color = color.slice( 1 );\r\n        useHash = true;\r\n      }\r\n\r\n      var num = parseInt( color, 16 );\r\n\r\n      var r = ( num >> 16 ) + ammount;\r\n\r\n      if( r > 255 ) {\r\n        r = 255;\r\n      }\r\n      else if( r < 0 ) {\r\n        r = 0;\r\n      }\r\n\r\n      var b = (( num >> 8 ) & 0x00FF ) + ammount;\r\n\r\n      if( b > 255 ) {\r\n        b = 255; \r\n      }\r\n      else if( b < 0 ) {\r\n        b = 0;\r\n      }\r\n\r\n      var g = (num & 0x0000FF) + ammount;\r\n\r\n      if( g > 255 ) {\r\n        g = 255;\r\n      }\r\n      else if( g < 0 ) {\r\n        g = 0;\r\n      }\r\n\r\n      return ( useHash ? '#' : '' ) + ( g |( b << 8 ) | ( r << 16 ) ).toString( 16 );\r\n    }\r\n\r\n\r\n    // String =============================================\r\n    /**\r\n     * [Remove all whitespace from a string]\r\n     * @param  {[string]} string \r\n     * @return {[string]}        [return string without whitespace]\r\n     */\r\n    Faze.fn.trim = function( string ) {\r\n      return string.replace( /\\s+/g, '' );\r\n    }\r\n\r\n    /**\r\n     * [Return size of string in bytes]\r\n     * @param  {[string]} string \r\n     * @return {[integer]}        [bytes of string]\r\n     */\r\n    Faze.fn.byteSize = function( string ) {\r\n      return new Blob([ string ]).size;\r\n    }\r\n\r\n    /**\r\n     * [Capitalize string]\r\n     * @param  {[string]} string    \r\n     * @param  {[boolean]} lowerRest [set all other characters to lowercase]\r\n     * @return {[string]}           \r\n     */\r\n    Faze.fn.capitalize = function( string, lowerRest ) {\r\n      return ( string[0].toUpperCase() + ( lowerRest ? string.substr( 1 ).toLowerCase() : string.substr( 1 ) ) );\r\n    }\r\n\r\n    /**\r\n     * [Capitalize each word]\r\n     * @param  {[type]} string [description]\r\n     * @return {[type]}        [description]\r\n     */\r\n    Faze.fn.capitalizeWords = function( string ) {\r\n      return string.replace( /\\b[a-z]/g, function( char ) {\r\n          return char.toUpperCase();\r\n      });\r\n    }\r\n\r\n    /**\r\n     * [DeCapitalize string]\r\n     * @param  {[string]} string   \r\n     * @param  {[boolean]} upperRest [Set all other characters to uppercase]\r\n     * @return {[string]}           [Return decapitalised string]\r\n     */\r\n    Faze.fn.deCapitalize = function( string, upperRest ) {\r\n      return string[0].toLowerCase() + ( upperRest ? string.substr( 1 ).toUpperCase() : string.substr( 1 ) );\r\n    }\r\n\r\n    // TODO: validate CSV data;\r\n    // Faze.fn.validateCSV = function( data ) {\r\n\r\n    // }\r\n\r\n    /**\r\n     * [Convert CSV string to array]\r\n     * @param  {[string]} data          [CSV string]\r\n     * @param  {[type]} delimiter     [description]\r\n     * @param  {[type]} onmitFirstRow [description]\r\n     * @return {[type]}               [description]\r\n     */\r\n    Faze.fn.csvToArray = function( data, delimiter, onmitFirstRow ) {\r\n      return data.slice( onmitFirstRow ? data.indexOf('\\n') + 1 : 0 ).split( '\\n' ).map( function( v ) {\r\n        return v.split( delimiter ? delimiter : ',' );\r\n      });\r\n    }\r\n\r\n    Faze.fn.csvToJSON = function( data, delimiter ) {\r\n      var titles = data.slice( 0, data.indexOf( '\\n' ) ).split( delimiter ? delimiter : ',' );\r\n      return data.slice( data.indexOf( '\\n' ) + 1 ).split( '\\n' ).map( function( v ) {\r\n          var values = v.split( delimiter ? delimiter : ',' );\r\n          return titles.reduce( function( obj, title, index ) {\r\n              return ( ( obj[title] = values[index] ), obj ) \r\n          }, {});\r\n      });\r\n    }\r\n\r\n    /**\r\n     * [escape HTML string for output to client]\r\n     * @param  {[string]} string [HTML risky string]\r\n     * @return {[string]}        [returned string with all html elements escaped]\r\n     */\r\n    Faze.fn.escapeHTML = function( string ){\r\n      return string.replace( /[&<>'\"]/g, function( tag ) {\r\n          return ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', \"'\": '&#39;', '\"': '&quot;' } [tag] || tag );\r\n      });\r\n    }\r\n\r\n    /**\r\n     * Convert camel case to seperated\r\n     * @param  {string} string    \r\n     * @param  {string} seperator seperator you with to use between words (Defaults: _)\r\n     * @return {string}           seperated string\r\n     */\r\n    Faze.fn.fromCamelCase = function( string, seperator ) {\r\n      return string.replace( /([a-z\\d])([A-Z])/g, '$1' + (seperator ? seperator : '_' ) + '$2' ).replace( /([A-Z]+)([A-Z][a-z\\d]+)/g, '$1' + ( seperator ? seperator : '_' ) + '$2' ).toLowerCase();\r\n    }\r\n\r\n    /**\r\n     * Indet string at every start of new line\r\n     * @param  {string} string \r\n     * @param  {interget} count  ammount of lines to indent\r\n     * @param  {string} indent string to use for indent\r\n     * @return {string}        Indented String\r\n     */\r\n    Faze.fn.indentString = function( string, count, indent ) {\r\n      return string.replace( /^/gm, ( indent ? indent : ' ' ).repeat( count ) );\r\n    }\r\n\r\n    /**\r\n     * Check if 1 word is an anagram of another\r\n     * @param  {string}  str1 word to check\r\n     * @param  {string}  str2 word to check against\r\n     * @return {boolean}      \r\n     */\r\n    Faze.fn.isAnagram = function( str1, str2 ) {\r\n      var normalize = function( str ) {\r\n        str.toLowerCase().replace( /[^a-z0-9]/gi, '' ).split('').sort().join('');\r\n      }\r\n      return normalize( str1 ) === normalize( str2 );\r\n    }\r\n\r\n    /**\r\n     * Check if string is lowercase\r\n     * @param  {string}  str \r\n     * @return {Boolean}    \r\n     */\r\n    Faze.fn.isLowerCase = function( str ) {\r\n      return str === str.toLowerCase();\r\n    }\r\n\r\n    /**\r\n     * Check if string is uppercase\r\n     * @param  {string}  str \r\n     * @return {Boolean}\r\n     */\r\n    Faze.fn.isUpperCase = function( str ) {\r\n      return str === str.toUpperCase();\r\n    }\r\n\r\n    /**\r\n     * Run function on every character of a string\r\n     * @param  {string}   str \r\n     * @param  {Function} fn  function callback for each character\r\n     * @return {string}       Edited string\r\n     */\r\n    Faze.fn.mapString = function( str, fn ) {\r\n      return str.split( '' ).map( function( c, i ) {\r\n        return fn( c, i, str );\r\n      }).join('');\r\n    }\r\n\r\n    /**\r\n     * Mask a number of characters of a string\r\n     * @param  {string} cc   string to mask\r\n     * @param  {interger} num  Number of characters to maske\r\n     * @param  {string} mask character to use as a mask (Defaults to '*')\r\n     * @return {string}      \r\n     */\r\n    Faze.fn.mask = function( cc, num, mask ) {\r\n      return cc.slice( - ( num ? num : 4 ) ).padStart( cc.length, ( mask ? mask : '*' ) );\r\n    }\r\n\r\n    /**\r\n     * Pad a string\r\n     * @param  {string} str    \r\n     * @param  {integer} length desired length of string\r\n     * @param  {string} char   String to use as padding (Defaults to ' ')\r\n     * @return {string}        Padded string\r\n     */\r\n    Faze.fn.pad = function( str, length, char ) {\r\n      return str.padStart( ( str.length + length ) / 2, ( char ? char : ' ' ) ).padEnd( length, ( char ? char : ' ' ) );\r\n    }\r\n\r\n    /**\r\n     * Pluralize value\r\n     * @param  {string} val    String to pluralize\r\n     * @param  {[type]} word   [description]\r\n     * @param  {[type]} plural [description]\r\n     * @return {[type]}        [description]\r\n     */\r\n    Faze.fn.pluralize = function( val, word, plural ) {\r\n      plural = (plural ? plural : word + 's');\r\n      var _pluralize = function( num,  word, plural ) {\r\n        return [ 1, -1 ].includes( Number( num ) ) ? word : plural;\r\n      }\r\n      if( typeof val === 'object' ) {\r\n        return function( num, word ) {\r\n          return _pluralize( num, word, val[word] );\r\n        }\r\n      }\r\n      return _pluralize( val, word, plural );\r\n    }\r\n\r\n    /**\r\n     * Remove non ASCII characters from string \r\n     * @param  {string} string \r\n     * @return {string}        String without ASCII characters\r\n     */\r\n    Faze.fn.removeNonASCII = function( string ) {\r\n      return string.replace( /[^\\x20-\\x7E]/g, '' );\r\n    }\r\n\r\n    // Array ==============================================\r\n    /**\r\n     * check if is array\r\n     * @param  {array}  array value to check\r\n     * @return {Boolean}       \r\n     */\r\n    Faze.fn.isArray = function( array ) { \r\n      return Array.isArray( array );\r\n    }\r\n\r\n    Faze.fn.inArray = function( value, array ) {\r\n      if( array && this.isArray( array ) ) {      \r\n        return array.indexOf( value ) > -1;\r\n      }\r\n      else if( this.isArray( this.nodes ) ) {\r\n        return this.nodes.indexOf( value ) > -1; \r\n      }\r\n      return false;\r\n    } \r\n\r\n    Faze.fn.merge = function( array1, array2 ) { // TODO: needs way more and to be way cleverer that this rubbish\r\n      var newArray = [];\r\n\r\n      for( var i = 0; i < array2.length; i++ ) {\r\n        newArray[i] = array2[i];\r\n      }\r\n\r\n      return newArray;\r\n    }\r\n\r\n    Faze.fn.makeArray = function( opt ) {\r\n      var ret = [];\r\n      if( opt != null ) {\r\n        if( isLikeArray( opt ) ) {\r\n          this.merge( ret, typeof opt === \"string\" ? [ opt ] : opt )\r\n        }\r\n        else {\r\n          [].push.call( ret, opt );\r\n        }\r\n      }\r\n      return ret;\r\n    }\r\n\r\n    Faze.fn.sort = function( array ) {\r\n      return array.sort( function( a, b ) {\r\n        return a.toLowerCase().localeCompare( b.toLowerCase() );\r\n      });\r\n    }\r\n\r\n    Faze.fn.random = function( array ) {\r\n      return array[ Math.floor( Math.random() * array.length ) ];\r\n    }\r\n\r\n    Faze.fn.flattenArray = function( array ) {\r\n      if( this.isArray( array ) ) {\r\n        return array.flat( Infinity );\r\n      }\r\n    }\r\n\r\n    Faze.fn.all = function( array, fn ) {\r\n      if( !fn ) {\r\n        fn = Boolean;\r\n      }\r\n      return array.every( fn );\r\n    }\r\n\r\n    Faze.fn.allEqual = function( array ) {\r\n      return array.every( function( val ) { return val === array[0] } );\r\n    }\r\n\r\n    Faze.fn.any = function( array, fn ) {\r\n      if( !fn ) {\r\n        fn = Boolean;\r\n      }\r\n      return array.some( fn );\r\n    }\r\n\r\n    Faze.fn.arrayToCSV = function( array, delimiter ) {\r\n      array.map( function( value ) {\r\n        return value.map( function( x ) {\r\n          return (isNaN( x ) ? '\"' + x.replace( /\"/g, '\"\"' ) + '\"' : x ) \r\n        } ).join( delimiter ? delimiter : ',' ).join( '\\n' );\r\n      });\r\n    }\r\n\r\n    Faze.fn.chunk = function( array, size ) {\r\n      Array.from({ length: Math.ceil( array.length / size ) }, function( v, i ) {\r\n        return array.slice( i * size, i * size, + size );\r\n      });\r\n    }\r\n\r\n    Faze.fn.filterFalse = function( array ) {\r\n      return array.filter( Boolean );\r\n    }\r\n\r\n    Faze.fn.difference = function( a, b ) {\r\n      var s = new Set( b );\r\n      return a.filter( function( x ) {\r\n        return !s.has( x );\r\n      });\r\n    }\r\n\r\n    Faze.fn.differenceBy = function( a, b, fn ) {\r\n      var s = new Set( b.map( fn ) );\r\n      return a.map( fn ).filter( function( el ) {\r\n        return !s.has( el );\r\n      }); \r\n    }\r\n\r\n    Faze.fn.fitlerNonUnique = function( array ) {\r\n      return array.filter( function( i ) {\r\n        return array.indexOf( i ) === array.lastIndexOf( i );\r\n      });\r\n    }\r\n\r\n    Faze.fn.findLast = function( array, fn ){\r\n      return array.filter( fn ).pop();\r\n    }\r\n\r\n    Faze.fn.findLastIndex = function( array, fn ) {\r\n      return array.map( function( val, i ) {\r\n        return [ i, val ]; \r\n      }).filter( function(  i, val ) {\r\n        return fn( val, i, array );\r\n      }).pop()[0];\r\n    }\r\n\r\n    Faze.fn.head = function( array ) {\r\n      return array[0];\r\n    }\r\n\r\n    Faze.fn.shuffle = function( ...array ) {\r\n      var m = array.length;\r\n      while( m ) {\r\n        var i = Math.floor( Math.random() * m-- );\r\n        [ array[m], array[i] ] = [ array[i], array[m] ];\r\n      }\r\n      return array;\r\n    }\r\n\r\n    Faze.fn.similarity = function( array, values ) {\r\n      return array.filter( function( v ) {\r\n        return values.includes( v );\r\n      });\r\n    }\r\n\r\n    Faze.fn.sortedIndex = function( array, n ) {\r\n      var isDescending = array[0] > array[ array.length - 1 ];\r\n      var index = array.findIndex( function( el ) {\r\n        return ( isDescending ? n >= el : n <= el );\r\n      });\r\n      return index === -1 ? array.length : index;\r\n    }\r\n\r\n\r\n    // Objects ============================================\r\n    Faze.fn.compare = function( object, propname ) {\r\n      return object.sort( function( a, b ) {\r\n        return a[propname].toLowerCase() == b[propname].toLowerCase() ? 0 : a[propname].toLowerCase() < b[propname].toLowerCase() ? -1 : 1;\r\n      }); \r\n    }\r\n\r\n    Faze.fn.print_r = function( object ) {\r\n      return JSON.stringify( object, null, '\\t' ).replace( /\\n/g, '<br/>' ).replace( /\\t/g, '&nbsp;&nbsp;&nbsp;' );\r\n    }\r\n\r\n    // Helper ========================================\r\n    Faze.fn.getType = function( val ) {\r\n      return val === undefined ? 'undefined' : val === null ? 'null' : val.constructor.name.toLowerCase();\r\n    }\r\n\r\n    Faze.fn.is = function( type, val ) {\r\n      return !['',null].includes( val ) && val.constructor === type;\r\n    }\r\n\r\n    Faze.fn.functionExists = function( functionName ) {\r\n      return typeof functionName == 'function';\r\n    }\r\n\r\n    Faze.fn.add = function( option ) {\r\n      if( option instanceof HTMLElement  ) {\r\n        this[this.length+1] = HTMLElement;\r\n      }\r\n      else if( option instanceof NodeList ) {\r\n        var list = this.merge( this.nodes, NodeList );\r\n        for( var i = 0; i < list.length; i++ ) {\r\n          this[this.length+1] = list[i];\r\n        }\r\n      }\r\n    }\r\n\r\n    Faze.fn.attr = function( options ) {\r\n      if( !options ) {\r\n        this.each( function( item ) {\r\n          return item.attributes;\r\n        });\r\n      }\r\n    }\r\n\r\n    Faze.fn.children = function() {\r\n      var children = [];\r\n      this.each( function( item ) {\r\n        if( item.hasChildNodes() ) {\r\n          children.push( this.makeArray( item.children ) );\r\n        }\r\n      });\r\n\r\n      return new Faze( children );\r\n    }\r\n\r\n    Faze.fn.clone = function( options ) {\r\n      var elems = [];\r\n      this.each( function( item ) {\r\n        elems.push( item.clone( options ) );\r\n      });\r\n      return elems;\r\n    }\r\n\r\n    Faze.fn.html = function() {\r\n      var str = '';\r\n      this.each( function( item ) {\r\n        str += item.outerHTML;\r\n      });\r\n      return str;\r\n    }\r\n\r\n    Faze.fn.text = function() {\r\n      var str = this.html();\r\n      return str.replace( /<[^>]*>/gm, '' );  \r\n    }\r\n\r\n    Faze.fn.isNumeric = function( number ) {\r\n      if( !( typeof number === \"string\" ) && !( typeof number === \"number\" )  ) {\r\n        return false;\r\n      }\r\n      return number.match( /^[\\d.]+?/ );\r\n    }\r\n\r\n    Faze.fn.attempt = function( fn, ...args ) {\r\n      try{\r\n        return fn( ...args );\r\n      }\r\n      catch( e ) {\r\n        return e instanceof Error ? e : new Error( e );\r\n      }\r\n    }\r\n\r\n    Faze.fn.on = function( eventType, callback, selector ) {\r\n      var events = eventType.split( ' ' );\r\n\r\n      for( var i = 0; i < events.length; i++ ) {\r\n        var event = events[i];\r\n\r\n        this.each( function( item ) {\r\n          if( !selector ){\r\n            item.addEventListener( event, callback );\r\n          }\r\n          else {\r\n            item.addEventListener( event, function(e) {\r\n              if( e.target && Faze( e.target ).hasClass( selector ) ) {\r\n                callback.call( this, e );\r\n              }\r\n            });\r\n          }\r\n        });\r\n\r\n      }\r\n    }\r\n\r\n    Faze.fn.wrap = function( html ) {\r\n      var wrapper = createNodes( html );\r\n\r\n      this.each( function( item ) {\r\n        item.parentNode.insertBefore( wrapper, item );\r\n        wrapper.appendChild( item );  \r\n      });\r\n    }\r\n\r\n    Faze.fn.poll = function( fn, timeout, interval ) {\r\n      var endTime = Number( new Date() ) + ( timeout || 2000 );\r\n      interval = interval || fn();\r\n      var checkCondition = function( resolve, reject ) {\r\n        var result = fn();\r\n        if( result ) {\r\n          resolve( result );\r\n        }\r\n        else if( Number( new Date() ) < endTime ) {\r\n          setTimeout( checkCondition, interval, resolve, reject );\r\n        }\r\n        else {\r\n          reject( new Error( 'Timed out for ' + fn + ': ' + arguments ) );\r\n        }\r\n      }\r\n\r\n      return new Promise( checkCondition );\r\n    }\r\n\r\n    Faze.fn.once = function( fn, context ) {\r\n      var result;\r\n\r\n      return function() {\r\n        if( fn ) {\r\n          result = fn.apply( context || this, arguments );\r\n        }\r\n\r\n        return result;\r\n      }\r\n    }\r\n\r\n    Faze.fn.throttle = function( fn, wait ) {\r\n      var inThrottle, lastFn, lastTime;\r\n      return function() {\r\n        var context = this, args = arguments;\r\n        if( !inThrottle ) {\r\n          fn.apply( context, args );\r\n          lastTime = Date.now();\r\n          inThrottle = true;\r\n        }\r\n        else {\r\n          clearTimeout( lastFn );\r\n          lastFn = setTimeout( function() {\r\n            if( Date.now() - lastTime >= wait ) {\r\n              fn.apply( context, args );\r\n              lastTime = Date.now();\r\n            }\r\n          }, Math.max( wait - ( Date.now() - lastTime ), 0 ) );\r\n        }\r\n      };\r\n    };\r\n\r\n    Faze.fn.debouce = function( func, wait, immediate ) {\r\n      var timeout;\r\n      return function() {\r\n        var context = this, args = arguments;\r\n        var later = function() {\r\n          timeout = null;\r\n          if( !immediate ) {\r\n            func.apply( context, args );\r\n          }\r\n        };\r\n        var callNow = immediate && !timeout;\r\n        clearTimeout( timeout );\r\n        timeout = setTimeout( later, wait );\r\n        if( callNow ) {\r\n          func.apply( context, args );\r\n        }\r\n      }\r\n    }\r\n\r\n    // Date ===========================================\r\n    Faze.fn.dayOfYear = function( date ){\r\n      return Math.floor( ( date - new Date( date.getFullYear(), 0, 0 ) ) / 1000 / 60 / 60 / 24 );\r\n    }\r\n\r\n\r\n    return new Faze();\r\n})();\n\n//# sourceURL=webpack:///./src/faze.js?");

/***/ })

/******/ });